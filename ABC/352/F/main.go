// 自分で記述したやつがバグが取れなかったので解答をコピーした。
// Code generated by Gottani; see https://github.com/ktateish/gottani/. DO NOT EDIT.
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

//line github.com/ywak/atcoder/lib/ds/arrays.go:9
type Int2d [][]int

func NewInt2d(a, b, value int) [][]int {
	base := make([]int, a*b)
	if value != 0 {
		for i := range base {
			base[i] = value
		}
	}
	arr := make([][]int, a)
	for i := range arr {
		arr[i] = base[(i * b):((i + 1) * b)]
	}

	return Int2d(arr)
}

func (arr *Int2d) Init(v int) {
	_a := (*arr)
	a := _a[0][0 : len(_a)*len(_a[0])]
	for i := 0; i < len(a); i++ {
		a[i] = v
	}
}

func NewInt3d(a, b, c, value int) [][][]int {
	arr := make([][][]int, a)
	for i := range arr {
		arr[i] = NewInt2d(b, c, value)
	}
	return arr
}

// 重み付きUnion-Findは集合と、各ノードがルートからどれくらい距離があるかを管理します。
//
//line github.com/ywak/atcoder/lib/ds/weighted-union-find.go:3
type WeightedUnionFind struct {
	par  []int
	rank []int
	diff []int
}

// NewWeightedUnionFindは重み付きUnion-Findの実装を返します。
func NewWeightedUnionFind(n int) *WeightedUnionFind {
	uf := WeightedUnionFind{
		par:  make([]int, n),
		rank: make([]int, n),
		diff: make([]int, n),
	}

	for i := 0; i < n; i++ {
		uf.par[i] = i
		uf.rank[i] = 0
		uf.diff[i] = 0
	}

	return &uf
}

// xが接続されているルートを返します。
func (uf *WeightedUnionFind) Root(x int) int {
	if uf.par[x] == x {
		return x
	}
	r := uf.Root(uf.par[x])
	uf.diff[x] += uf.diff[uf.par[x]]
	uf.par[x] = r
	return r
}

// xの重みを返します。
func (uf *WeightedUnionFind) Weight(x int) int {
	uf.Root(x)
	return uf.diff[x]
}

// xとyが同じ集合にいるかを判断します。
func (uf *WeightedUnionFind) IsSame(x, y int) bool {
	return uf.Root(x) == uf.Root(y)
}

// weight[y]-weight[x] = wとなるようにマージします
func (uf *WeightedUnionFind) Merge(x, y, w int) bool {
	w += uf.Weight(x)
	w -= uf.Weight(y)
	x = uf.Root(x)
	y = uf.Root(y)

	if x == y {
		return false
	}
	if uf.rank[x] < uf.rank[y] {
		w = -w
		x, y = y, x
	}
	if uf.rank[x] == uf.rank[y] {
		uf.rank[x]++
	}
	uf.par[y] = x
	uf.diff[y] = w
	return true
}

// weight[y]-weight[x]を返します。
func (uf *WeightedUnionFind) Diff(x, y int) int {
	return uf.Weight(y) - uf.Weight(x)
}

//line github.com/ywak/atcoder/lib/io/io.go:16
type In struct {
	// NextString は 次の入力を文字列として読み込んで返します。
	NextString func() string
}

type Out struct {
	writer io.Writer
	Flush  func()
}

type InitIoProps struct {
	// バッファを行うかどうか。
	DoBuffer bool

	// 行単位で読むか、改行単位で読むか。
	ReadLine bool
}

func InitIo(props *InitIoProps) (*In, *Out) {
	bufsize := 4 * 1024 * 1024 // 4MB

	// 入力はずっとバッファーでいいらしい。ほんとう？
	// TODO バッファなしfmt.Fscanf(os.Stdin)だとTLEだった。要調査
	_in := bufio.NewScanner(os.Stdin)
	if !props.ReadLine {
		_in.Split(bufio.ScanWords)
	}
	_in.Buffer(make([]byte, bufsize), bufsize)
	in := func() string {
		_in.Scan()
		return _in.Text()
	}

	// 出力はバッファon/offが必要
	var out io.Writer
	var flush func()

	if props.DoBuffer {
		_out := bufio.NewWriterSize(os.Stdout, bufsize)
		out = _out
		flush = func() {
			_out.Flush()
		}
	} else {
		out = os.Stdout
		flush = func() {}
	}

	return &In{in}, &Out{out, flush}
}

// NextBytes は 次の入力をbyteの配列として読み込んで返します。
// 遅いから極力使わない。
func (in *In) NextBytes() []byte {
	return []byte(in.NextString())
}

// NextInt は 次の入力を数値として読み込んで返します。
func (in *In) NextInt() int {
	i, _ := strconv.Atoi(in.NextString())
	return i
}

// NextInt2 は 次の2つの入力を数値として読み込んで返します。
func (in *In) NextInt2() (int, int) {
	return in.NextInt(), in.NextInt()
}

// NextInt2d は 次の2つの入力を数値n1,n2として読み込んで、n1+d1, n2+d2を返します。
func (in *In) NextInt2d(d1, d2 int) (int, int) {
	return in.NextInt() + d1, in.NextInt() + d2
}

// NextInt3 は 次の3つの入力を数値として読み込んで返します。
func (in *In) NextInt3() (int, int, int) {
	return in.NextInt(), in.NextInt(), in.NextInt()
}

// NextInt2d は 次の3つの入力を数値n1,n2,n3として読み込んで、n1+d1, n2+d2, n3+d3を返します。
func (in *In) NextInt3d(d1, d2, d3 int) (int, int, int) {
	return in.NextInt() + d1, in.NextInt() + d2, in.NextInt() + d3
}

// NextInt4 は 次の4つの入力を数値として読み込んで返します。
func (in *In) NextInt4() (int, int, int, int) {
	return in.NextInt(), in.NextInt(), in.NextInt(), in.NextInt()
}

// NextInts は 次のn個の入力を数値として読み込んで、配列として返します。
func (in *In) NextInts(n int) sort.IntSlice {
	a := make([]int, n)
	for i := 0; i < n; i++ {
		a[i] = in.NextInt()
	}
	return sort.IntSlice(a)
}

// NextLongIntAsArray は 次の入力を数値として読み込み、各桁を要素とした配列を返します。
func (in *In) NextLongIntAsArray() []int {
	s := in.NextString()
	l := len(s)
	arr := make([]int, l)
	for i := 0; i < l; i++ {
		arr[i] = int(s[i] - '0')
	}

	return arr
}

// NextBytesOffsetは、次の入力を文字列として読み込み、各文字cについて(c-offset)に置き換えた配列を返します。
func (in *In) NextBytesOffset(offset byte) []int {
	s := in.NextString()
	arr := make([]int, len(s))
	for i, v := range s {
		arr[i] = int(byte(v) - offset)
	}
	return arr
}

// NextFloat は 次の入力を実数値として読み込み、値を返します。
func (in *In) NextFloat() float64 {
	f, _ := strconv.ParseFloat(in.NextString(), 64)
	return f
}

// Println は引数をスペース区切りで出力し、最後に改行を出力します。
func (out *Out) Println(a ...interface{}) {
	fmt.Fprintln(out.writer, a...)
}

// Printf はformatにしたがってaを整形して出力します。
func (out *Out) Printf(format string, a ...interface{}) {
	fmt.Fprintf(out.writer, format, a...)
}

// PrintStringsln は文字列配列の各要素をスペース区切りで出力し、最後に改行を出力します。
func (out *Out) PrintStringsln(a []string) {
	out.Println(strings.Join(a, " "))
}

// PrintIntsLn は整数配列の各要素をスペース区切りで出力し、最後に改行を出力します。
func (out *Out) PrintIntsLn(a []int) {
	b := make([]string, len(a))
	for i, v := range a {
		b[i] = fmt.Sprint(v)
	}
	out.Println(strings.Join(b, " "))
}

func (out *Out) PrintLenAndIntsLn(a []int) {
	b := make([]string, len(a)+1)
	b[0] = fmt.Sprint(len(a))
	for i, v := range a {
		b[i+1] = fmt.Sprint(v)
	}
	out.Println(strings.Join(b, " "))
}

// Putcは一文字出力します。
func (out *Out) Putc(c byte) {
	out.Printf("%c", c)
}

// YesNo は condが真ならYes, 偽ならNoを出力します。
func (out *Out) YesNo(cond bool) {
	if cond {
		out.Println("Yes")
	} else {
		out.Println("No")
	}
}

func (out *Out) YESNO(cond bool) {
	if cond {
		out.Println("YES")
	} else {
		out.Println("NO")
	}
}

//line main.go:16
func calc(in *In, out *Out) {
	n, m := in.NextInt2()
	uf := NewWeightedUnionFind(n)
	for i := 0; i < m; i++ {
		a, b, c := in.NextInt3()
		a--
		b--
		uf.Merge(b, a, c)
	}

	// グループを求める
	used := map[int]bool{}
	type group struct {
		order int
		u     []int
		w     []int
	}

	gs := []*group{}
	for i := 0; i < n; i++ {
		r := uf.Root(i)
		if used[r] {
			continue
		}
		used[r] = true

		g := group{0, []int{}, []int{}}
		gs = append(gs, &g)

		for j := i; j < n; j++ {
			if uf.Root(j) == r {
				g.u = append(g.u, j)
				g.w = append(g.w, uf.Diff(i, j))
			}
		}
		for l := range g.u {
			for r := l + 1; r < len(g.u); r++ {
				if g.w[l] > g.w[r] {
					g.w[l], g.w[r] = g.w[r], g.w[l]
					g.u[l], g.u[r] = g.u[r], g.u[l]
				}
			}
		}
		offset := g.w[0]
		for j := range g.u {
			g.w[j] -= offset
			g.order |= 1 << g.w[j]
		}
		// debug(g)
	}

	// dp[s][g][i]は順位の集合sが使用済みでグループgが適用されているとき、iの順位としてあり得る順位
	dp := NewInt3d(1<<n, len(gs)+1, n, 0)
	pats := []int{0}
	for j, g := range gs {
		pats2 := map[int]bool{}
		for _, s := range pats {
			// このグループの覆う区間
			for t := 0; t < n; t++ {
				nx := g.order << t
				if nx >= 1<<n {
					break
				}

				// 重複があれば次へ
				if s&nx != 0 {
					continue
				}

				// nxが採用可能なので、全順位をコピーし、グループ内の順位を適用する
				for u := 0; u < n; u++ {
					dp[s|nx][j+1][u] |= dp[s][j][u]
				}

				// 今回増える人の分を適用する
				for i, u := range g.u {
					dp[s|nx][j+1][u] |= 1 << (g.w[i] + t)
				}
				pats2[s|nx] = true
			}
		}
		pats = []int{}
		for v := range pats2 {
			pats = append(pats, v)
		}
	}

	ans := make([]int, n)
	last := dp[1<<n-1][len(gs)]
	order := map[int]int{}
	for i := 0; i < n; i++ {
		order[1<<i] = i + 1
	}
	// i番目の人はj番目の人との順位が決まっているか？
	for i, pat := range last {
		// debug(i, fmt.Sprintf("%010b", pat))
		if v, ex := order[pat]; ex {
			ans[i] = v
		} else {
			ans[i] = -1
		}
	}

	out.PrintIntsLn(ans)
}

func main() {
	in, out := InitIo(&InitIoProps{
		DoBuffer: true, // インタラクティブならfalseにすること。
		ReadLine: false,
	})
	defer out.Flush()

	calc(in, out)
}
